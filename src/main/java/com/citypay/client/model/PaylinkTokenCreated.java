/*
 * CityPay Payment API
 *  Welcome to the CityPay API, a robust HTTP API payment solution designed for seamless server-to-server  transactional processing. Our API facilitates a wide array of payment operations, catering to diverse business needs.  Whether you're integrating Internet payments, handling Mail Order/Telephone Order (MOTO) transactions, managing  Subscriptions with Recurring and Continuous Authority payments, or navigating the complexities of 3-D Secure  authentication, our API is equipped to support your requirements. Additionally, we offer functionalities for  Authorisation, Refunding, Pre-Authorisation, Cancellation/Voids, and Completion processing, alongside the capability  for tokenised payments.  ## Compliance and Security Overview <aside class=\"notice\">   Ensuring the security of payment transactions and compliance with industry standards is paramount. Our API is    designed with stringent security measures and compliance protocols to safeguard sensitive information and meet    the rigorous requirements of Visa, MasterCard, and the PCI Security Standards Council. </aside>  ### Key Compliance and Security Measures  * **TLS Encryption**: All data transmissions must utilise TLS version 1.2 or higher, employing [strong cryptography](#enabled-tls-ciphers). Our infrastructure strictly enforces this requirement to maintain the integrity and confidentiality of data in transit. We conduct regular scans and assessments of our TLS endpoints to identify and mitigate vulnerabilities. * **Data Storage Prohibitions**: Storing sensitive cardholder data (CHD), such as the card security code (CSC) or primary account number (PAN), is strictly prohibited. Our API is designed to minimize your exposure to sensitive data, thereby reducing your compliance burden. * **Data Masking**: For consumer protection and compliance, full card numbers must not be displayed on receipts or any customer-facing materials. Our API automatically masks PANs, displaying only the last four digits to facilitate safe receipt generation. * **Network Scans**: If your application is web-based, regular scans of your hosting environment are mandatory to identify and rectify potential vulnerabilities. This proactive measure is crucial for maintaining a secure and compliant online presence. * **PCI Compliance**: Adherence to PCI DSS standards is not optional; it's a requirement for operating securely and legally in the payments ecosystem. For detailed information on compliance requirements and resources, please visit the PCI Security Standards Council website [https://www.pcisecuritystandards.org/](https://www.pcisecuritystandards.org/). * **Request Validation**: Our API includes mechanisms to verify the legitimacy of each request, ensuring it pertains to a valid account and originates from a trusted source. We leverage remote IP address verification alongside sophisticated application firewall technologies to thwart a wide array of common security threats.  ## Getting Started Before integrating with the CityPay API, ensure your application and development practices align with the outlined compliance and security measures. This preparatory step is crucial for a smooth integration process and the long-term success of your payment processing operations.  For further details on API endpoints, request/response formats, and code examples, proceed to the subsequent sections of our documentation. Our aim is to provide you with all the necessary tools and information to integrate our payment processing capabilities seamlessly into your application.  Thank you for choosing CityPay API. We look forward to supporting your payment processing needs with our secure, compliant, and versatile API solution. 
 *
 * Contact: support@citypay.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.citypay.client.model;

import java.util.Objects;
import com.citypay.client.model.PaylinkAttachmentResult;
import com.citypay.client.model.PaylinkErrorCode;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.citypay.client.JSON;

/**
 * PaylinkTokenCreated
 */
public class PaylinkTokenCreated {
  public static final String SERIALIZED_NAME_ATTACHMENTS = "attachments";
  @SerializedName(SERIALIZED_NAME_ATTACHMENTS)
  private PaylinkAttachmentResult attachments;

  public static final String SERIALIZED_NAME_BPS = "bps";
  @SerializedName(SERIALIZED_NAME_BPS)
  private String bps;

  public static final String SERIALIZED_NAME_DATE_CREATED = "date_created";
  @SerializedName(SERIALIZED_NAME_DATE_CREATED)
  private OffsetDateTime dateCreated;

  public static final String SERIALIZED_NAME_ERRORS = "errors";
  @SerializedName(SERIALIZED_NAME_ERRORS)
  private List<PaylinkErrorCode> errors = new ArrayList<>();

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_IDENTIFIER = "identifier";
  @SerializedName(SERIALIZED_NAME_IDENTIFIER)
  private String identifier;

  public static final String SERIALIZED_NAME_MODE = "mode";
  @SerializedName(SERIALIZED_NAME_MODE)
  private String mode;

  public static final String SERIALIZED_NAME_QRCODE = "qrcode";
  @SerializedName(SERIALIZED_NAME_QRCODE)
  private String qrcode;

  public static final String SERIALIZED_NAME_RESULT = "result";
  @SerializedName(SERIALIZED_NAME_RESULT)
  private Integer result;

  public static final String SERIALIZED_NAME_SERVER_VERSION = "server_version";
  @SerializedName(SERIALIZED_NAME_SERVER_VERSION)
  private String serverVersion;

  public static final String SERIALIZED_NAME_SOURCE = "source";
  @SerializedName(SERIALIZED_NAME_SOURCE)
  private String source;

  public static final String SERIALIZED_NAME_TOKEN = "token";
  @SerializedName(SERIALIZED_NAME_TOKEN)
  private String token;

  public static final String SERIALIZED_NAME_URL = "url";
  @SerializedName(SERIALIZED_NAME_URL)
  private String url;

  public static final String SERIALIZED_NAME_USC = "usc";
  @SerializedName(SERIALIZED_NAME_USC)
  private String usc;

  public PaylinkTokenCreated() {
  }

  public PaylinkTokenCreated attachments(PaylinkAttachmentResult attachments) {
    this.attachments = attachments;
    return this;
  }

  /**
   * Get attachments
   * @return attachments
   */
  @javax.annotation.Nullable
  public PaylinkAttachmentResult getAttachments() {
    return attachments;
  }

  public void setAttachments(PaylinkAttachmentResult attachments) {
    this.attachments = attachments;
  }


  public PaylinkTokenCreated bps(String bps) {
    this.bps = bps;
    return this;
  }

  /**
   * true if BPS has been enabled on this token.
   * @return bps
   */
  @javax.annotation.Nullable
  public String getBps() {
    return bps;
  }

  public void setBps(String bps) {
    this.bps = bps;
  }


  public PaylinkTokenCreated dateCreated(OffsetDateTime dateCreated) {
    this.dateCreated = dateCreated;
    return this;
  }

  /**
   * Date and time the token was generated.
   * @return dateCreated
   */
  @javax.annotation.Nullable
  public OffsetDateTime getDateCreated() {
    return dateCreated;
  }

  public void setDateCreated(OffsetDateTime dateCreated) {
    this.dateCreated = dateCreated;
  }


  public PaylinkTokenCreated errors(List<PaylinkErrorCode> errors) {
    this.errors = errors;
    return this;
  }

  public PaylinkTokenCreated addErrorsItem(PaylinkErrorCode errorsItem) {
    if (this.errors == null) {
      this.errors = new ArrayList<>();
    }
    this.errors.add(errorsItem);
    return this;
  }

  /**
   * Get errors
   * @return errors
   */
  @javax.annotation.Nullable
  public List<PaylinkErrorCode> getErrors() {
    return errors;
  }

  public void setErrors(List<PaylinkErrorCode> errors) {
    this.errors = errors;
  }


  public PaylinkTokenCreated id(String id) {
    this.id = id;
    return this;
  }

  /**
   * A unique id of the request.
   * @return id
   */
  @javax.annotation.Nonnull
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }


  public PaylinkTokenCreated identifier(String identifier) {
    this.identifier = identifier;
    return this;
  }

  /**
   * The identifier as presented in the TokenRequest.
   * @return identifier
   */
  @javax.annotation.Nullable
  public String getIdentifier() {
    return identifier;
  }

  public void setIdentifier(String identifier) {
    this.identifier = identifier;
  }


  public PaylinkTokenCreated mode(String mode) {
    this.mode = mode;
    return this;
  }

  /**
   * Determines whether the token is &#x60;live&#x60; or &#x60;test&#x60;.
   * @return mode
   */
  @javax.annotation.Nullable
  public String getMode() {
    return mode;
  }

  public void setMode(String mode) {
    this.mode = mode;
  }


  public PaylinkTokenCreated qrcode(String qrcode) {
    this.qrcode = qrcode;
    return this;
  }

  /**
   * A URL of a qrcode which can be used to refer to the token URL.
   * @return qrcode
   */
  @javax.annotation.Nullable
  public String getQrcode() {
    return qrcode;
  }

  public void setQrcode(String qrcode) {
    this.qrcode = qrcode;
  }


  public PaylinkTokenCreated result(Integer result) {
    this.result = result;
    return this;
  }

  /**
   * The result field contains the result for the Paylink Token Request. 0 - indicates that an error was encountered while creating the token. 1 - which indicates that a Token was successfully created.
   * @return result
   */
  @javax.annotation.Nonnull
  public Integer getResult() {
    return result;
  }

  public void setResult(Integer result) {
    this.result = result;
  }


  public PaylinkTokenCreated serverVersion(String serverVersion) {
    this.serverVersion = serverVersion;
    return this;
  }

  /**
   * the version of the server performing the call.
   * @return serverVersion
   */
  @javax.annotation.Nullable
  public String getServerVersion() {
    return serverVersion;
  }

  public void setServerVersion(String serverVersion) {
    this.serverVersion = serverVersion;
  }


  public PaylinkTokenCreated source(String source) {
    this.source = source;
    return this;
  }

  /**
   * The incoming IP address of the call.
   * @return source
   */
  @javax.annotation.Nullable
  public String getSource() {
    return source;
  }

  public void setSource(String source) {
    this.source = source;
  }


  public PaylinkTokenCreated token(String token) {
    this.token = token;
    return this;
  }

  /**
   * A token generated for the request used to refer to the transaction in consequential calls.
   * @return token
   */
  @javax.annotation.Nonnull
  public String getToken() {
    return token;
  }

  public void setToken(String token) {
    this.token = token;
  }


  public PaylinkTokenCreated url(String url) {
    this.url = url;
    return this;
  }

  /**
   * The Paylink token URL used to checkout by the card holder.
   * @return url
   */
  @javax.annotation.Nullable
  public String getUrl() {
    return url;
  }

  public void setUrl(String url) {
    this.url = url;
  }


  public PaylinkTokenCreated usc(String usc) {
    this.usc = usc;
    return this;
  }

  /**
   * A UrlShortCode (USC) used for short links.
   * @return usc
   */
  @javax.annotation.Nullable
  public String getUsc() {
    return usc;
  }

  public void setUsc(String usc) {
    this.usc = usc;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PaylinkTokenCreated paylinkTokenCreated = (PaylinkTokenCreated) o;
    return Objects.equals(this.attachments, paylinkTokenCreated.attachments) &&
        Objects.equals(this.bps, paylinkTokenCreated.bps) &&
        Objects.equals(this.dateCreated, paylinkTokenCreated.dateCreated) &&
        Objects.equals(this.errors, paylinkTokenCreated.errors) &&
        Objects.equals(this.id, paylinkTokenCreated.id) &&
        Objects.equals(this.identifier, paylinkTokenCreated.identifier) &&
        Objects.equals(this.mode, paylinkTokenCreated.mode) &&
        Objects.equals(this.qrcode, paylinkTokenCreated.qrcode) &&
        Objects.equals(this.result, paylinkTokenCreated.result) &&
        Objects.equals(this.serverVersion, paylinkTokenCreated.serverVersion) &&
        Objects.equals(this.source, paylinkTokenCreated.source) &&
        Objects.equals(this.token, paylinkTokenCreated.token) &&
        Objects.equals(this.url, paylinkTokenCreated.url) &&
        Objects.equals(this.usc, paylinkTokenCreated.usc);
  }

  @Override
  public int hashCode() {
    return Objects.hash(attachments, bps, dateCreated, errors, id, identifier, mode, qrcode, result, serverVersion, source, token, url, usc);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PaylinkTokenCreated {\n");
    sb.append("    attachments: ").append(toIndentedString(attachments)).append("\n");
    sb.append("    bps: ").append(toIndentedString(bps)).append("\n");
    sb.append("    dateCreated: ").append(toIndentedString(dateCreated)).append("\n");
    sb.append("    errors: ").append(toIndentedString(errors)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    identifier: ").append(toIndentedString(identifier)).append("\n");
    sb.append("    mode: ").append(toIndentedString(mode)).append("\n");
    sb.append("    qrcode: ").append(toIndentedString(qrcode)).append("\n");
    sb.append("    result: ").append(toIndentedString(result)).append("\n");
    sb.append("    serverVersion: ").append(toIndentedString(serverVersion)).append("\n");
    sb.append("    source: ").append(toIndentedString(source)).append("\n");
    sb.append("    token: ").append(toIndentedString(token)).append("\n");
    sb.append("    url: ").append(toIndentedString(url)).append("\n");
    sb.append("    usc: ").append(toIndentedString(usc)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("attachments");
    openapiFields.add("bps");
    openapiFields.add("date_created");
    openapiFields.add("errors");
    openapiFields.add("id");
    openapiFields.add("identifier");
    openapiFields.add("mode");
    openapiFields.add("qrcode");
    openapiFields.add("result");
    openapiFields.add("server_version");
    openapiFields.add("source");
    openapiFields.add("token");
    openapiFields.add("url");
    openapiFields.add("usc");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("id");
    openapiRequiredFields.add("result");
    openapiRequiredFields.add("token");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to PaylinkTokenCreated
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!PaylinkTokenCreated.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in PaylinkTokenCreated is not found in the empty JSON string", PaylinkTokenCreated.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!PaylinkTokenCreated.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `PaylinkTokenCreated` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : PaylinkTokenCreated.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `attachments`
      if (jsonObj.get("attachments") != null && !jsonObj.get("attachments").isJsonNull()) {
        PaylinkAttachmentResult.validateJsonElement(jsonObj.get("attachments"));
      }
      if ((jsonObj.get("bps") != null && !jsonObj.get("bps").isJsonNull()) && !jsonObj.get("bps").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `bps` to be a primitive type in the JSON string but got `%s`", jsonObj.get("bps").toString()));
      }
      if (jsonObj.get("errors") != null && !jsonObj.get("errors").isJsonNull()) {
        JsonArray jsonArrayerrors = jsonObj.getAsJsonArray("errors");
        if (jsonArrayerrors != null) {
          // ensure the json data is an array
          if (!jsonObj.get("errors").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `errors` to be an array in the JSON string but got `%s`", jsonObj.get("errors").toString()));
          }

          // validate the optional field `errors` (array)
          for (int i = 0; i < jsonArrayerrors.size(); i++) {
            PaylinkErrorCode.validateJsonElement(jsonArrayerrors.get(i));
          };
        }
      }
      if (!jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if ((jsonObj.get("identifier") != null && !jsonObj.get("identifier").isJsonNull()) && !jsonObj.get("identifier").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `identifier` to be a primitive type in the JSON string but got `%s`", jsonObj.get("identifier").toString()));
      }
      if ((jsonObj.get("mode") != null && !jsonObj.get("mode").isJsonNull()) && !jsonObj.get("mode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mode").toString()));
      }
      if ((jsonObj.get("qrcode") != null && !jsonObj.get("qrcode").isJsonNull()) && !jsonObj.get("qrcode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `qrcode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("qrcode").toString()));
      }
      if ((jsonObj.get("server_version") != null && !jsonObj.get("server_version").isJsonNull()) && !jsonObj.get("server_version").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `server_version` to be a primitive type in the JSON string but got `%s`", jsonObj.get("server_version").toString()));
      }
      if ((jsonObj.get("source") != null && !jsonObj.get("source").isJsonNull()) && !jsonObj.get("source").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `source` to be a primitive type in the JSON string but got `%s`", jsonObj.get("source").toString()));
      }
      if (!jsonObj.get("token").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `token` to be a primitive type in the JSON string but got `%s`", jsonObj.get("token").toString()));
      }
      if ((jsonObj.get("url") != null && !jsonObj.get("url").isJsonNull()) && !jsonObj.get("url").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `url` to be a primitive type in the JSON string but got `%s`", jsonObj.get("url").toString()));
      }
      if ((jsonObj.get("usc") != null && !jsonObj.get("usc").isJsonNull()) && !jsonObj.get("usc").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `usc` to be a primitive type in the JSON string but got `%s`", jsonObj.get("usc").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!PaylinkTokenCreated.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'PaylinkTokenCreated' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<PaylinkTokenCreated> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(PaylinkTokenCreated.class));

       return (TypeAdapter<T>) new TypeAdapter<PaylinkTokenCreated>() {
           @Override
           public void write(JsonWriter out, PaylinkTokenCreated value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public PaylinkTokenCreated read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of PaylinkTokenCreated given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of PaylinkTokenCreated
   * @throws IOException if the JSON string is invalid with respect to PaylinkTokenCreated
   */
  public static PaylinkTokenCreated fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, PaylinkTokenCreated.class);
  }

  /**
   * Convert an instance of PaylinkTokenCreated to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

